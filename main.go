package main

import (
	"embed"
	"io/fs"
	"log"
	"fmt"
	"os"
	"mime/multipart"
	"io"
	"strconv"
	"net/http"
	"encoding/json"



)

//go:embed all:nextjs/dist
var nextFS embed.FS

func main() {
	// Root at the `dist` folder generated by the Next.js app.
	distFS, err := fs.Sub(nextFS, "nextjs/dist")
	if err != nil {
		log.Fatal(err)
	}

	// The static Next.js app will be served under `/`.
	http.Handle("/", http.FileServer(http.FS(distFS)))
	http.HandleFunc("/api/lcio", handleLcio)
	http.HandleFunc("/api/hplot", handleHplot)

	// Start HTTP server at :8080.
	log.Println("Starting HTTP server at http://localhost:8080 ...")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

type Params struct {
	Title string
	Npoints string
    Mu string
    Sigma string
    Nbins string
    Min string
    Max string
}

func handleHplot(res http.ResponseWriter, req *http.Request) {  
	var p Params

    err := json.NewDecoder(req.Body).Decode(&p)
    if err != nil {
        http.Error(res, err.Error(), http.StatusBadRequest)
        return
    }

    // Do something with the Person struct...
	title := p.Title
	npoints, err := strconv.Atoi(p.Npoints)
	mu, err := strconv.ParseFloat(p.Mu, 64)
	sigma, err := strconv.ParseFloat(p.Sigma, 64)
	nbins, err := strconv.Atoi(p.Nbins)
	min, err := strconv.ParseFloat(p.Min, 64)
	max, err := strconv.ParseFloat(p.Max, 64)

	HandleH1DPlot(title, npoints, mu, sigma, nbins, min, max)
    img, err := os.Open("uploaded/h1d_plot.png")
    if err != nil {
        log.Fatal(err) // perhaps handle this nicer
    }
    defer img.Close()
    res.Header().Set("Content-Type", "image/jpeg") // <-- set the content-type header
    io.Copy(res, img)

	
}



func handleLcio(res http.ResponseWriter, req *http.Request) {  
	var (  
		 status int  
		 err  error  
	)  
	defer func() {  
		 if nil != err {  
			  http.Error(res, err.Error(), status)  
		 }  
	}()  
	// parse request  
   // const _24K = (1 << 20) * 24  
	if err = req.ParseMultipartForm(32 << 20); nil != err {  
		 status = http.StatusInternalServerError  
		 return  
	} 
	fmt.Println("No memory problem")
	for _, fheaders := range req.MultipartForm.File {  
		 for _, hdr := range fheaders {  
			  // open uploaded  
			  var infile multipart.File  
			  if infile, err = hdr.Open(); nil != err {  
				   status = http.StatusInternalServerError  
				   return  
			  }  
			  // open destination  
			  var outfile *os.File  
			  if outfile, err = os.Create("./uploaded/" + hdr.Filename); nil != err {  
				   status = http.StatusInternalServerError  
				   return  
			  }  
			  // 32K buffer copy  
			  var written int64  
			  if written, err = io.Copy(outfile, infile); nil != err {  
				   status = http.StatusInternalServerError  
				   return  
			  }  
			  fmt.Printf("uploaded file:" + hdr.Filename + ";length:" + strconv.Itoa(int(written)))

		 }  
	}
	data   := GetEventData()

	res.Write(data)  



	

} 



